# 线性表

## 顺序存储

~~~C
typedef struct {
    ElemType data[MAXSIZE];
    int last;
} List;
~~~

### 顺序表的归并

```cpp
void MergeList(List La, List Lb, List &Lc) {
    // 已知线性表 La 和 Lb 中的数据元素按值非递减排列。
    // 归并 La 和 Lb 得到新的线性表 Lc，Lc 的数据元素也按值非递减排列。
    InitList(Lc);
    int i =1, j = 1;
    int k = 0;
  
    while ((i <= La_len) && (j <= Lb_len)) { // La 和 Lb 均非空
        GetElem(La, i, ai); 
        GetElem(Lb, j, bj);
        if (ai <= bj) {
            ListInsert(Lc, ++k, ai); 
            ++i;
        }
        else {
            ListInsert(Lc, ++k, bj);
            ++j; 
        }
    }
    
    while (i <= La_len) {
        GetElem(La, i++, ai);
        ListInsert(Lc, ++k, ai);
    }
    while (j <= Lb_len) {
        GetElem(Lb, j++, bj); 
        ListInsert(Lc, ++k, bj);
    }
} // MergeList
```

## 链式存储

~~~C
typedef struct Node {
    ElemType data;
    struct Node *next;
} List; 
~~~

### 单链表逆置

- 每次操作都将指针反转

~~~C
List* inverse(List *L)
{
    List *p = L;
    List *q;
    List *head;

    q = p->next;
    p->next = NULL; 
    head = p;
    p = q;
    
    while (p) {
        q = p->next;
        p->next = head;
        head = p;
        p = q;
    }
    
    return head;
}
~~~

### 链表归并

```cpp
void MergeList_L(LinkList &La, LinkList &Lb, LinkList &Lc) {
    // 已知单链线性表 La 和 Lb 的元素按值非递减排列。
    // 归并 La 和 Lb 得到新的单链线性表 Lc，Lc 的元素也按值非递减排列。
    pa = La->next; 
    pb = Lb->next;
    Lc = pc = La;  // 用 La 的头结点作为 Lc 的头结点
    
    while (pa && pb) {
        if (pa->data <= pb->data) {
            pc->next = pa; 
            pc = pa;
            pa = pa->next;
        } else {
            pc->next = pb; 
            pc = pb; 
            pb = pb->next;
        }
    }
    
    pc->next = pa ? pa : pb;  // 插入剩余段
    free(Lb);                 // 释放 Lb 的头结点
} // MergeList_L
```

### 链表求交集

>已知两个链表A和B分别表示两个集合，其元素递增排列。写一算法，求A与B的交集，其元素也递增排列，并存放于A链表中。

~~~C
void Intersection_A_B(List* La, List* Lb) {
    ListNode *pa = La->next;     // A 的第一个数据节点
    ListNode *pb = Lb->next;     // B 的第一个数据节点
    ListNode *pre = La;          // pre 始终是 pa 的前驱，用于删除节点
    ListNode *temp;

    while (pa && pb) {
        if (pa->data == pb->data) {
            // 相等，保留该节点
            pre = pa;
            pa = pa->next;
            pb = pb->next;
        } else if (pa->data < pb->data) {
            // A 当前节点不在交集中，删除它
            temp = pa;
            pa = pa->next;
            pre->next = temp->next;
            free(temp);
        } else {
            // B 当前节点太小，跳过
            pb = pb->next;
        }
    }

    // 删除 A 中剩余的所有节点（因为 B 已到末尾）
    while (pa) {
        temp = pa;
        pa = pa->next;
        pre->next = pa;
        free(temp);
    }
}
~~~

## 一元多项式的表示及其相加

