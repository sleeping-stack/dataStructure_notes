# 线性表

## 顺序存储

~~~C
typedef struct {
    ElemType data[MAXSIZE];
    int last;
} List;
~~~

### 顺序表的归并

```cpp
void MergeList(List La, List Lb, List &Lc) {
    // 已知线性表 La 和 Lb 中的数据元素按值非递减排列。
    // 归并 La 和 Lb 得到新的线性表 Lc，Lc 的数据元素也按值非递减排列。
    InitList(Lc);
    int i =1, j = 1;
    int k = 0;
  
    while ((i <= La_len) && (j <= Lb_len)) { // La 和 Lb 均非空
        GetElem(La, i, ai); 
        GetElem(Lb, j, bj);
        if (ai <= bj) {
            ListInsert(Lc, ++k, ai); 
            ++i;
        }
        else {
            ListInsert(Lc, ++k, bj);
            ++j; 
        }
    }
    
    while (i <= La_len) {
        GetElem(La, i++, ai);
        ListInsert(Lc, ++k, ai);
    }
    while (j <= Lb_len) {
        GetElem(Lb, j++, bj); 
        ListInsert(Lc, ++k, bj);
    }
} // MergeList
```

## 链式存储

~~~C
typedef struct Node {
    ElemType data;
    struct Node *next;
} List; 
~~~

### 单链表逆置

- 每次操作都将指针反转

~~~C
List* inverse(List *L)
{
    List *p = L;
    List *q;
    List *head;

    q = p->next;
    p->next = NULL; 
    head = p;
    p = q;
    
    while (p) {
        q = p->next;
        p->next = head;
        head = p;
        p = q;
    }
    
    return head;
}
~~~

### 链表归并

```cpp
void MergeList_L(LinkList &La, LinkList &Lb, LinkList &Lc) {
    // 已知单链线性表 La 和 Lb 的元素按值非递减排列。
    // 归并 La 和 Lb 得到新的单链线性表 Lc，Lc 的元素也按值非递减排列。
    pa = La->next; 
    pb = Lb->next;
    Lc = pc = La;  // 用 La 的头结点作为 Lc 的头结点
    
    while (pa && pb) {
        if (pa->data <= pb->data) {
            pc->next = pa; 
            pc = pa;
            pa = pa->next;
        } else {
            pc->next = pb; 
            pc = pb; 
            pb = pb->next;
        }
    }
    
    pc->next = pa ? pa : pb;  // 插入剩余段
    free(Lb);                 // 释放 Lb 的头结点
} // MergeList_L
```

### 链表求交集

>已知两个链表A和B分别表示两个集合，其元素递增排列。写一算法，求A与B的交集，其元素也递增排列，并存放于A链表中。

~~~C
void Intersection_A_B(List* La, List* Lb) {
    ListNode *pa = La->next;     // A 的第一个数据节点
    ListNode *pb = Lb->next;     // B 的第一个数据节点
    ListNode *pre = La;          // pre 始终是 pa 的前驱，用于删除节点
    ListNode *temp;

    while (pa && pb) {
        if (pa->data == pb->data) {
            // 相等，保留该节点
            pre = pa;
            pa = pa->next;
            pb = pb->next;
        } else if (pa->data < pb->data) {
            // A 当前节点不在交集中，删除它
            temp = pa;
            pa = pa->next;
            pre->next = temp->next;
            free(temp);
        } else {
            // B 当前节点太小，跳过
            pb = pb->next;
        }
    }

    // 删除 A 中剩余的所有节点（因为 B 已到末尾）
    while (pa) {
        temp = pa;
        pa = pa->next;
        pre->next = pa;
        free(temp);
    }
}
~~~

## 一元多项式的表示及其相加

### 存储结构(有序链表)

~~~C
typedef struct {	// 多项式的项作为LinkList的数据元素
    float coef;		// 系数
    int expn;		// 指数
} ElemType;

typedef LinkList polynominal;
~~~

### 算法

~~~C
void AddPolyn(polynomial &Pa, polynomial &Pb) {
    // 多项式加法: Pa = Pa + Pb，利用两个多项式的结点构成“和多项式”。
    ha = GetHead(Pa);  
    hb = GetHead(Pb);   // ha 和 hb 分别指向 Pa 和 Pb 的头结点
    qa = NextPos(Pa, ha);
    qb = NextPos(Pb, hb); // qa 和 qb 分别指向 Pa 和 Pb 中当前结点
    
    while (qa && qb) {  // qa 和 qb 均非空
        a = GetCurElem(qa);
        b = GetCurElem(qb); // a 和 b 为两表中当前比较元素
   
        switch (cmp(a, b)) {
            case -1:  // 多项式 PA 中当前结点的指数值小
                ha = qa; 
                qa = NextPos(Pa, qa);
                break;
            case 0:   // 两者的指数值相等
                sum = a.coef + b.coef;
                if (sum != 0.0) {  // 修改多项式 PA 中当前结点的系数值
                    SetCurElem(qa, sum);
                    ha = qa;
                } 
                else {  // 删除多项式 PA 中当前结点
                    DelFirst(ha, qa);
                    FreeNode(qa);
                }
                
                DelFirst(hb, qb); 
                FreeNode(qb); 
                qb = NextPos(Pb, hb);
                qa = NextPos(Pa, ha);
                break;
            case 1:   // 多项式 PB 中当前结点的指数值小
                DelFirst(hb, qb); 
                InsFirst(ha, qb);
                qb = NextPos(Pb, hb);
                ha = NextPos(Pa, ha);
                break;
        }
    }
    if (!ListEmpty(Pb))
        Append(Pa, qb);  // 链接 Pb 中剩余结点
    
    FreeNode(hb);  // 释放 Pb 的头结点
} // AddPolyn
~~~

### 乘法

两个一元多项式相乘的算法，可以利用两个一元多项式相加的算法来实现，因为乘法运算可以分解为一系列的加法运算。假设 \( A(x) \) 和 \( B(x) \) 为式 (2-7) 的多项式，则

$$
M(x) = A(x) \times B(x)
= A(x) \times \left[ b_1 x^{e_1} + b_2 x^{e_2} + \cdots + b_n x^{e_n} \right]
= \sum_{i=1}^n b_i A(x) x^{e_i}
$$

其中，每一项都是一个一元多项式。
